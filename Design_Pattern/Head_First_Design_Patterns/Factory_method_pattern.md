## Chapter 04. 팩토리 패턴

객체의 인스턴스를 만드는 작업이 항상 공개되어 있어야 하는 것은 아니며, 모든 것을 공개했다가는 결합과 관련된 문제가 생길 수 있다는 것을 배우게 될 것이다.

특정 구현을 바탕으로 프로그래밍 하지 않아야 한다. new를 쓸 때마다 결국 특정 구현을 사용함. new는 구현체에 대한 인스턴스를 만드는 것이다. 구현체를 바탕으로 코딩을 하면 추후 코드 변경이 발생할 때, 해당 구현체에 의존하는 모든 코드를 수정해야 한다. 이는 의존 관계에 대한  유연성을 떨어뜨리는 것이다.

객체를 생성하기 위해서 new 연산자는 필수적으로 필요하다. 코드 수정에 어떻게 대응하는지가 핵심이다. 이를 해결하기 위해 특정 구현체에 의존하는 것이 아니라, 인터페이스를 바탕으로 객체 관계를 구성해야 한다.(다형성을 활용한 확장 가능)




## 간단한 팩토리

### 1. 피자 메뉴별 주문 객체

```
Pizza orderPizza(String type) {
	Pizza pizza;

	if (type.equals("cheese") {
		pizza = new CheesePizza();
	} else if (type.equasl("greek") {
		pizza = new GreekPizza();
	} else if (type.equals("pepperoni") {
		pizza = new PepperoniPizza();
	}
	
	pizza.prepare();
	pizza.bake();
	pizza.cut();
	pizza.box();

	return pizza;
}
```

피자 종류(type)를 바탕으로 구상 클래스(서브클래스 or 구현체) 인스턴스를 생성한다.

피자 메뉴가 변경되면 구상 클래스의 인스턴스 생성부를 모두 수정해야 한다. prepare(), bake(), cake(), box()는 변경 부분이 없지만 type을 체크하여 구상 클래스의 인스턴스를 생성하는 부분에는 수정이 발생

```
Pizza orderPizza(String type) {
	Pizza pizza;

	if (type.equals("cheese") {
		pizza = new CheesePizza();
	} ~~else if (type.equasl("greek") {~~
		// 그리스식 피자 메뉴에서 없어짐
		~~pizza = new GreekPizza();~~
	} else if (type.equals("pepperoni") {
		pizza = new PepperoniPizza();
	} else if (type.equals("bulgogi") {
		// 불고기 피자 추가
		pizza = new BulgogiPizza();
	}
	
	pizza.prepare();
	pizza.bake();
	pizza.cut();
	pizza.box();

	return pizza;
}
```

### 2. 피자 객체 생성부 분리

객체 생성을 처리하는 클래스를 팩토리라고 부른다.

Pizza 팩토리를 만들고 나면 orderPizza() 메소드는 새로 만든 객체(팩토리)의 클라이언트가 된다. orderPizza() 메소드는 더 이상 어떤 피자를 만들어야 하는지 고민하지 않아도 된다. 피자를 받아서 prepare(), bake(), cut(), box() 메소드를 호출하기만 하면 된다.

```
public class SimplePizzaFactory {
	public Pizza createPizza(String type) {
		Pizza pizza = null;

		// 피자 객체 생성부
		if (type.equals("cheese") {
				pizza = new CheesePizza();
			} else if (type.equals("pepperoni") {
				pizza = new PepperoniPizza();
			} else if (type.equals("bulgogi") {
				pizza = new BulgogiPizza();
			}
	}
}
```

- 객체 성성부를 분리 하였을 때의 장점 
  - SimplePizzaFactory를 사용하는 클라이언트가 매우 많다고 가정해보자. 클라이언트에서는 어떤 구현체인지 알 필요가 없다.(SimplePizzaFactory가 이 일을 처리하기 때문이다.)
  - 피자 생성 작업을 하는 클래스를 캡슐화시켜 놓으면 구현을 변경해야 하는 경우 팩토리 클래스 하나만 고치면 된다.




## 피자 Store 분점

orderPizza() 메소드는 추상클래스(PizzaStore)에 구현되어 있다. 주문 시스템 자체는 모든 분점에서 똑같이 진해되어야 하기 때문이다.(동일한 공통 행동) 분점마다 달라지는 것은 피자 스타일.


구상 클래스의 인스턴스를 만드는 일을 한 객체에서 전부 처리하는 방식에서 일련의 서브클래스에서 처리하는 방식으로 변경.

```
public abstract class PizzaStore {
	public Pizza orderPizza(String type) {
		Pizza pizza;

		pizza = createPizza(type);
		
		pizza.prepare();
		pizza.bake();
		pizza.cut();
		pizza.box();

		return pizza;
	}

	// Pizza 인스턴스를 만드는 일은 팩토리 역할을 하는 메소드에서 맡아서 처리.
	protected abstract Pizza createPizza(String type);
}
```

팩토리 메소드는 객체 생성을 처리하며, 팩토리 메소드를 이용하면 객체를 생성하는 작업을 서브클래스에 캡슐화 시킬 수 있다. 이렇게 하면 슈퍼클래스에 있는 클라이언트 코드와 서브클래스에 있는 객체 생성 코드를 분리시킬 수 있다.




## 피자 팩토리 메소드를 이용한 피자 주문

- i. NYPizzaStore, ChicagoPizzaStore 인스턴스 생성. 
  - 분점이 뉴욕인지, 시카고인지 선택.
- ii. nyPizzaStoe.order("cheese"); 
  - 피자 가게가 확보되면 주문을 받는다.
- iii. orderPizza() 메소드 안에서 createPizza() 메소드 호출
- iv. createPizza() 메소드로부터 Pizza 객체 반환. 
  - 어떤 종류의 피자인지 orderPizza() 메소드에서는 알지 못한다.
- v. prepare(), bake(), cut(), box() 작업 차례로 수행.




## 팩토리 메소드 패턴의 정의

```
- 팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만듭니다. 
- 팩토리 메소드 패턴을 이용하면 클래스의 인스턴스를 만드는 일을 서브클래스에게 맡기는 것이죠.
```

모든 팩토리 패턴에서는 객체 생성을 캡슐화 한다. 팩토리 메소드 패턴에서는 서브클래스에서 어떤 클래스를 만들지를 결정하게 함으로써 객체 생성을 캡슐화 한다.




## Q/A

- 간단한 팩토리와 팩토리 메소드 패턴의 차이 
  - 간단한 팩토리는 팩토리가 PizzaStore 안에 포함되는 별개의 객체이다. 간단한 팩토리에서 객체 생성을 캡슐화 하는 방법을 사용하긴 하지만 팩토리 메소드 패턴처럼 강력한 유연성을 제공하진 못한다. 생성하는 제품을 마음대로 변경할 수 없기 때문이다.
  - 팩토리 메소드 패턴은 createPizza() 추상 메소드가 정의되어 있는 추상 클래스를 확장하여 만든다. 서브 클래스에서 어떤 일을 할지 구체적으로 결정한다.

객체 생성은 피할 수 없는 현실이다. 객체를 생성하지 않고는 자바 프로그램을 만들 수가 없다. 하지만 현실을 제대로 이해하고 있다면, 생성 코드를 한 곳에 모아놓고 체계적으로 관리할 수 있는 디자인을 만들 수 있다. 이렇게 잘 모아두고 나면 객체 인스턴스를 만드는 코드를 보호하고 관리하기가 편해진다.



## 의존성 뒤집기 원칙 (Dependency Inversion Principle)

- 디자인 원칙 — 추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하도록 만들지 않도록 한다.
- 고수준 구성요소가 저수준 구성요소에 의존하면 안 된다. (항상 추상화에 의존하도록 만들어야 한다.)
- 구상 클래스처럼 구체적인 것이 아닌 추상 클래스나 인터페이스와 같이 추상저인 것에 의존하는 코드를 만들어야 한다.
- 팩토리 메소드 패턴이 의존성 뒤집기 원칙을 준수하기 위해 쓸 수 있는 유일한 기법은 아니다. 하지만 가장 적합한 방법 가운데 하나라고는 할 수 있다.
- 의존성 뒤집기 원칙에서 뭘 뒤집다는 걸까 ? 
  - 객치지향 디자인을 할 때 일반적으로 생각하는 방법과는 반대로, 뒤집어서 생각.
  - 의존성이 위에서 아래로 내려가기만 했던 것과는 반대로 뒤집어져 있다.
  - 고수준 모듈과 저수준 모듈이 둘 다 하나의 추상 클래스에 의존.
- 객체지향 디자인을 위한 가이드라인 
  - 어떤 변수에도 구상 클래스에 대한 레퍼런스를 저장하지 마라. 
    - new 연산자를 사용하여 구상 클래스에 대한 레퍼런스를 사용하지 않아야 한다. 팩토리를 써서 구상 클래스에 대한 레퍼런스를 변수에 저장하는 일을 미리 방지.
  - 구상 클래스에서 유도된 클래스를 만들지 마라. 
    - 구상 클래스에 의존하게 된다. 추상화된 것으로부터 클래스를 만들어야 한다.
  - 베이스 클래스에 이미 구현되어 있던 메소드를 오버라이드 하지 마라.
- 원칙을 지키는 데 도움이 될만한 가이드라인 
  - 어떤 변수에도 구상 클래스에 대한 레퍼런스를 저장하지 않아야 한다. 
    - new 연산자를 사용하지 않고 팩토리를 사용
  - 구상 클래스에서 유도된 클래스를 만들지 않아야 한다. 
    - 인터페이스나 추상 클래스처럼 추상화된 것으로부터 클래스를 만들어야 한다.
  - 베이스 클래스에 이미 구현되어 있던 메소드를 오버라이드 하지 않아야 한다. 
    - 베이스 클래스에서 메소드를 정의할 때는 모든 서브 클래스에서 공유할 수 있는 것만 정의해야 한다.



## 원재료의 종류

원재료를 생산하는 공장(팩토리)을 만들고 분점까지 재료를 배달. 뉴욕으로 배달되는 재료들과 시카고로 배달되는 재료들이 서로 다르다. 서로 다른 종류의 재료들을 제공하기 위해 원재료군(families of ingredients)을 처리할 방법을 생각해 봐야 한다.

```
public interface PizzaIngredientFactory {
	public Dough createDough();
	public Sauce createSauce();
	public Cheese createCheese();
	public Veggies[] createVeggies();
	public Pepperoni createPepperoni();
	public clams createClam();
}
```



## 추상 팩토리 패턴 정의

```
추상 팩토리 패턴에서는 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 저장하지 않고도 생성할 수 있다.
```

서로 연관된 일련의 제품군을 만들 때 쓸 수 있는 패턴.



## 팩토리 메소드 패턴과 추상 팩토리 패턴

공통점

- 특정 애플리케이션을 특정 구현으로부터 분리시킨다.

차이점

- 팩토리 메소드 패턴 
  - 상속을 통해서 서브 클래스에서 객체를 생성한다.
  - 팩토리 메소드 패턴을 통해서 객체를 생성할 때는 클래스를 확장하고, 팩토리 메소드를 오버라이드 해야 한다.
  - 클라이언트 코드와 인스턴스를 만들어야 할 구상 클래스를 분리시켜야 할 때 사용한다.
  - 어떤 구상 클래스를 필요로 하게 될지 미리 알 수 없는 경우 유용하다.
  - 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하도록 한다. 팩토리 메소드를 이용하면 인스턴스를 만드는 일을 서브클래스로 미룰 수 있다.
- 추상 팩토리 패턴 
  - 구현을 통해서 객체를 생성한다.
  - 제품군을 만들기 위한 추상 형식을 제공한다. 제품이 생산되는 방법은 이 형식의 서브클래스에서 정의된다.
  - 클라이언트에서 서로 연관된 일련의 제품들을 만들어야 할 때, 즉 제품군을 만들어야 할 때 사용한다.
  - 서로 연관된, 또는 의존적인 객체들로 이루어진 제품군을 생성하기 위한 인터페이스를 제공한다. 구상 클래스는 서브 클래스에 의해 만들어진다.



## 정리

- 팩토리 메소드 패턴과 추상 팩토리 패턴 모두 객체 생성을 캡슐화 해서 코드와 구상 형식을 분리시킬 수 있게 해준다.
- 간단한 팩토리는 엄밀하게 말해서 디자인 패턴은 아니지만 클라이언트와 구상 클래스를 분리시키기 위한 간단한 기법으로 활용할 수 있다.
- 팩토리 메소드 패턴에서는 상속을 활용한다. 객체 생성이 서브클래스에게 위임된다.
- 팩토리는 구상 클래스가 아닌 추상 클래스/인터페이스에 맞춰서 코딩할 수 있게 해주는 강력한 기법이다.



### 참고

- [Head First Design Patterns](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=582754)
