## 객체지향언어
객체지향언어는 기존의 프로그래밍 언어와 다른 전혀 새로운 것이 아니라, 기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가한 보다 발전된 형태의 것이다.



### Chapter 6. 객체지향언어 프로그래밍 1



#### \# 객체지향언어의 역사

> 초창기의 과학자들은 모의실험을 위해 실제 세계와 유사한 가상 세계를 컴퓨터 속에 구현하고자 노력, 이러한 노력으로 `객체지향이론 탄생`

> 객체지향이론의 기본 개념 `실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.`

> 객체지향이론은 상속, 캡슐화, 추상화 개념을 중심으로 점차 구체적으로 발전되었으며, 1960년대 중반 객체지향이론을 프로그래밍언어에 적용한 `시뮬라(Simula)`라는 최초의 객체지향언어 탄생.



#### \# 객체지향의 주요 특징

재사용성과 유지보수 그리고 중복된 코드의 제거.

> 코드의 `재사용성이 높다.`
>
> - 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.

> 코드의 `관리가 용이하다.`
>
> - 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.

> 신뢰성이 높은 프로그래밍을 가능하게 한다.
>
> - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.



#### \# 클래스

클래스란 `객체를 정의해놓은 것`, 또는 `객체의 설계도 또는 틀` . 클래스는 객체를 생성하는데 사용되며, 객체는 클래스에 정의된 대로 생성된다.

> **클래스의 정의** : 클래스란 객체를 정의해 놓은 것이다.

> **클래스의 용도** : 클래스는 객체를 생성하는데 사용된다.



#### \# 객체

`프로그래밍에서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것.`

> **객체의 정의** : 실제로 존재하는 것. 사물 또는 개념

> **객체의 용도** : 객체가 가지고 있는 기능과 속성에 따라 다름.

> 클래스와 객체의 관계는 실생활에서 제품 설계도와 제품과의 관계라고 볼 수 있다.
>
> 객체를 사용한다는 것은 객체가 가지고 있는 속성과 기능을 사용한다는 뜻이다.
>
> 객체지향적 관점에서 클래스는 `객체를 생성하기 위한 틀`이다.
>
> 프로그래밍적 관점에서 클래스는 `데이터와 함수의 결합`



#### \# 인스턴스 (Instance)

어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라 한다.. 클래스로부터 객체를 만드는 과정을 클래스의 `인스턴스화(Instantiate)`라고 한다.

> ```
> 클래스 ==인스턴스화==> 인스턴스(객체)
> ```
>
> 인스턴스는 객체와 같은 의미이지만, 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 있으며, 인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 갖고 있다.
>
> - '책상은 인스턴스다.' 보다는 '책상은 객체다.'
> - '책상은 책상 클래스의 객체이다.' 보다는 '책상은 책상 클래스의 인스턴스이다.'

> **객체의 생성**
>
> ````java
> 클래스명 변수명;						// 클래스의 객체를 참조하기 위한 참조변수 선언
> 변수명 = new 클래스명();		// new 연산자로 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장. 
> ````
>
> ````java
> ClassName referenceVariable; // 참조변수 선언. 메모리에 참조변수 referenceVariable를 위한 공간 마련된다. 아직 인스턴스가 생성되지 않은 상태이므로, 참조변수로는 아무거도 할 수 없다.
> referenceVariable = new ClassName();	// 연산자 new에 의해 ClassName 클래스의 인스턴스가 메모리의 빈 공간에 생성된다. 대입연산자(=)에 의해 생성된 객체의 주소값이 참조변수 referenceVariable에 저장된다. 참조변수 referenceVariable을 통해 ClassName 인스턴스에 접근 가능.
> ````
>
> ````java
> referenceVariable.memberVariable = 10;	// 참조변수.멤버변수로 인스턴스의 멤버변수(속성) 사용.
> ````
>
> ````java
> referenceVariable.member();	// 참조변수의 메서드 사용.
> ````
>
> `인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.`



#### \# 객체의 구성요소 - 속성, 기능

객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있다. 객체가 가지고 있는 속성과 기능을 그  객체의 멤버(구성원)라 한다.

> **속성 (property)**
>
> - 멤버변수 (member variable), 필드 (field)

> **기능 (function)**
>
> - 메서드 (method), 행위 (behavior)



#### \# 객체 배열

배열로 객체를 다루는 것. 실제로는 배열 안에 객체가 저장되는 것은 아니고, 객체의 주소가 저장된다. 사실 객체 배열은 참조변수들을 하나로 묶은 `참조 변수 배열`인 것이다.

>```java
>Tv tv1, tv2, tv3 ==> Tv[] tvArr = new Tv[3]; 
>```
>
>길이가 3인 객체 배열 tvArr 생성. 각 요소는 참조변수의 기본값인 null로 자동 초기화 된다. 객체 배열은 객체의 주소를 저장할 수 있다.
>
>객체 배열을 생성하는 것은, 그저 객체를 다루기 위한 참조변수들이 만들어진 것일 뿐, 아직 객체가 저장되지 않았다.
>
>```java
>Tv[] tvArr = new Tv[3];
>tvArr[0] = new Tv();	// 인스턴스 생성하여 참조변수에 주소 저장.
>tvArr[1] = new Tv();
>tvArr[2] = new Tv();
>```



#### \# 클래스에 대한 또 다른 정의

> 객체지향이론의 관점
>
> - 클래스는 객체를 생성하기 위한 틀.

> 프로그래밍적인 관점
>
> - 클래스는 데이터와 함수의 결합.
> - 서로 관련된 변수들을 정의하고, 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이 바로 클래스이다.
>
> 데이터 처리를 위한 데이터 저장형태의 발전과정
>
> - 변수 => 배열 => 구조체 => 클래스
> - **변수** : 하나의 데이터를 저장할 수 있는 공간.
> - **배열** : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간.
> - **구조체** : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간.
> - **클래스** : 데이터와 함수의 결합 (구조체 + 함수)



#### \# 사용자 정의 타입 (user-defined type)

프로그래밍 언어에서 제공하는 자료형(`primitive type`) 외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 사용자 정의 타입이라고 한다.

> 기본형 (primitive type)
>
> - 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)
>
> 참조형 (reference type)
>
> - 객체의 주소를 저장한다. 8개의 기본형을 제외한 나머지 타입. 사용자 정의 타입 포함.



#### \# 변수

```java
class Variables {
  // 클래스 영역
  int iv;	// 인스턴스 변수
  static int cv;	// 클래스 변수 (static 변수)
  
  void method() {
    // 메서드 영역
    int lv = 0;	// 지역 변수
  }
}
```

>**지역 변수**
>
>- 메서드 내에 선언
>- for, while문 같은 블럭{} 내에서 선언된 경우, 해당 블럭{} 안에서만 사용 가능

>**인스턴스 변수**
>
>- 클래스의 `인스턴스 생성할 때` 만들어진다. 인스턴스 변수의 값을 읽어오거나 저장하기 위해서는 먼저 인스턴스를 생성해야 한다.
>- 인스턴스마다 고유한 상태를 유지해야 하는 속성의 경우, 인스턴스 변수로 선언

>**클래스 변수**
>
>- static
>- 모든 인스턴스가 공통된 저장공간(변수)을 공유
>- 인스턴스 생성하지 않고도 사용가능
>- `클래스가 메모리에 로딩될 때 생성`되어 프로그램이 종료될 때까지 유지된다.
>- `참조변수의 선언이나 객체의 생성과 같이 클래스의 정보가 필요할 때, 클래스는 메모리에 로딩된다.`

> 인스턴스 변수는 인스턴스가 생성될 때마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 갖는다.



#### \# 메서드 사용 이유

메서드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.

>**높은 재사용성**
>
>- 한번 만들어 놓은 메서드는 몇 번이고 호출 할 수 있다.

>**중복된 코드의 제거**
>
>- 반복되는 코드를 하나의 메서드로 작성
>- 전체 소스 코드의 길이도 짧아지고, 변경사항이 발생했을 때 수정해야 할 코드의 양이 줄어들어 오류가 발생할 가능성도 함께 줄어든다.

>**프로그램의 구조화**
>
>- 큰 규모의 프로그램에서는 문장들을 작업단위로 나눠서 여러 개의 메서드에 담아 프로그램의 구조를 단순화시키는 것이 필수적이다.



#### \# return문

> 원래는 반환값의 유무에 관계없이 모든 메서드에는 적어도 하나의 return문이 있어야 한다. 그런데도 반환값이 void인 경우, return문 없이도 아무런 문제가 없었던 이유는 `컴파일러가 메서드의 마지막에 'return;'을 자동적으로 추가해주었기 때문이다.`



#### \# JVM의 메모리 구조

응용 프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
- 메서드 영역(method area) / (class area) / (static area)
> - 클래스 변수(class variable)
> - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 `클래스에 대한 정보`(클래스 데이터)를 이곳에 저장한다. 이 때, 그 클래스의 클래스 변수(class variable)도 이 영역에 함께 저장된다.
- 힙(heap)
> - new 연산자를 통해 만들어진 인스턴스가 생성되는 공간
> - 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. `인스턴스 변수`(instance variable)들이 생성되는 공간이다.
>- 스택 영역에 저장되는 로컬변수, 매개변수와 달리 힙 영역에 보관되는 메모리는 메서드 호출이 끝나도 사라지지 않고 유지된다. (가비지 컬렉터가 관리)
>- 런 타임에 크기 결정 
- 호출스택(call stack 또는 execution stack)
>- 메서드의 작업에 필요한 메모리 공간을 제공한다.
>- 메서드가 호출되면 호출스택에 호출된 메서드를 위한 메모리가 할당, 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.
>- 컴파일 타임에 크기 결정



#### \# 기본형 매개변수와 참조형 매개변수

- 기본형 매개변수(primitive type)
>- 단순히 저장된 값만 알 수 있다. (read only)
- 참조형 매개변수(reference type)
>- 값이 저장된 곳의 주소 알 수 있다. (read & write)



#### \# 참조형 반환타입

반환 타입이 `참조형` 이라는 것은 메서드가 `객체의 주소`를 반환한다는 것을 의미한다.



#### \# 재귀호출

메서드의 내부에서 메서드 자신을 다시 호출하는 것을 `재귀호출(recursive call)`이라 한다.
- 대부분의 재귀호출은 반복문으로 작성 가능
- 반복문은 그저 같은 문장을 반복해서 수행한다. 메서드를 호출하는 것은 `매개변수 복사`와 `종료 후 복귀할 주소 저장` 등 추가 작업이 필요하기 때문에, 반복문보다 재귀호출의 수행시간이 더 오래 걸린다.
- 효율적인 면으로만 보면 반복문을 사용하는 것이 맞으나, 재귀호출이 주는 `논리적 간결함` 때문에 재귀호출을 사용한다. 몇 겹의 반복문과 조건문으로 복잡하게 작성된 코드가 재귀호출로 작성하면 보다 단순한 구조로 바뀔 수도 있다. 다소 비효율적이더라도 가독성이 좋은 코드를 작성하는 것이 논리적 오류가 발생할 확률도 줄어들고 나중에 수정하기도 좋다.



#### \# 클래스 메서드(static 메서드)와 인스턴스 메서드

- 클래스 영역에 선언된 변수를 멤버변수라 한다. 멤버변수 중에 static이 붙은 것은 클래스 변수(static 변수), static이 붙지 않은 것은 인스턴스 변수라 한다. 멤버변수는 인스턴스 변수와 static 변수 모두 통칭하는 말이다.
- 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static 사용.
- 클래스 변수는 인스턴스 생성하지 않아도 사용할 수 있다.
>- 클래스가 메모리에 올라갈 떄 이미 자동적으로 생성
- 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
>- 생성 시점이 달라, 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다.



#### \# 오버로딩 (overloading)

- 한 클래스 내에 같은 이름의 메서드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름 사용할 수 있다.
- 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것.



#### \# 가변인자(variable arguments)

- 자바 5부터 매개변수 동적으로 지정 가능.
- '타입... 변수명'
- 가변인자를 매개변수 중에서 제일 마지막에 선언해야 한다.
- 가변인자는 내부적으로 배열을 이용한다.
- 가능하면 가변인자를 사용한 메서드는 오버로딩 하지 않는 것이 좋다.



#### \# 생성자 (Constructor)

생성자는 인스턴스가 생성될 떄 호출되는 '인스턴스 초기화 메서드'이다.
- 생성자의 이름은 클래스의 이름과 같아야 한다.
- 생성자는 리턴 값이 없다.
- 연산자 new 가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.
```
Card c = new Card();
1. 연산자 new에 의해서 메모리(heep)에 Card 클래스의 인스턴스가 생성된다.
2. 생성자 Card()가 호출되어 수행된다.
3. 연산자 new의 결과로, 생성된 Card 인스턴스의 주소가 반환되어 참조변수 c에 저장된다.
```
- 기본 생성자 (default constructor)
>- 컴팡일러가 자동적으로 기본 생성자를 추가해주는 경우는 '클래스 내에 생성자가 하나도 없을 때'뿐이다.
- 매개변수 있는 생성자 
>- 인스턴스마다 각기 다른 값으로 초기화되어야 하는 경우가 많기 때문에 매개변수를 사용한 초기화는 매우 유용하다.
- 생성자에서 다른 생성자 호출하기 - this(), this
>- 생성자의 이름으로 클래스 이름 대신 this를 사용한다.
>- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
>- 'this'는 참조변수로 인스턴스 자신을 가리킨다.
>- static 메서드에서는 'this' 사용할 수 없다. (static 메서드 호출 시점에 인트턴스 존재하지 않을 수도 있기 때문.)
>- `this` => 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다. 



#### \# 변수의 초기화

- 변수의 초기화는 경우에 따라서 필수적이기도 하고 선택적이기도 하지만, 가능하면 선언과 동시에 적절한 값으로 초기화 하는 것이 바람직하다.
- 멤버변수는 자동적으로 변수의 자료형에 맞는 기본값으로 초기화된다.
- 지역변수는 사용하기 전에 반드시 초기화해야 한다.
```
멤버변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.
```
- 명시적 초기화 (explicit initialization)
- 초기화 블럭 (initialization block)
>- 클래스 초기화 블럭
>- 인스턴스 초기화 블럭
>- 초기화 작업이 복잡하여 명시적 초기화만으로 부족한 경우 초기화 블럭 사용.
>- `생성자보다 인스턴스 초기화 블럭이 먼저 수행된다.`
>- 인스턴스 변수의 초기화는 주로 생성자를 사용하고, 인스턴스 초기화 블럭은 `모든 생성자에서 공통으로 수행돼야 하는 코드를 넣는데 사용한다.`
```java
class InitBlock {
    static {  /* 클래스 초기화 블럭. */  }
    
    {  /* 인스턴스 초기화 블럭 */  }
}
```



#### \# 멤버변수의 초기화 시기와 순서

- 클래스변수의 초기화 순서
>- 기본값 => 명시적초기화 => 클래스 초기화 블럭
>- 기본값 => 명시적초기화 => 인스턴스 초기화 블럭 => 생성자

<br />

### Reference.
- [자바의정석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001)