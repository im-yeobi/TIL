## 객체지향언어



### Chapter 7. 객체지향언어 프로그래밍 2



#### \# 상속 (inheritance)
기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 상속을 통해 코드를 공통적으로 관리할 수 있기 때문에, 코드의 재사용성을 높이고 코드의 중복을 제거할 수 있다.
 ````java
class Child extends Parent {
    // ...
}
 ````
>  조상 클래스 : 부모(parent)클래스, 상위(super)클래스, 기반(base)클래스
>
> 자손 클래스 : 자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스

>상속을 받는다는 것은 조상 클래스를 `확장(extend)`한다는 의미로 해석할 수도 있으며, 이것이 상속에 사용되는 키워드가 `extends`인 이유이기도 하다.
>
>생성자와 초기화 블럭은 상속되지 않는다. `멤버만 상속된다.`
>
>접근 제어자가 private 또는 default인 멤버들은 상속되지 않는다기보다 상속은 받지만 자손 클래스로부터의 접근이 제한되는 것이다.
>
>`자손 클래스의 인스턴스를 생성하면, 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스가 생성된다.`



 #### \# 포함관계

 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것. 
````java
class Circle {
    Point c = new Point();  // 포함관계
    int r;
}

class Point {
    int x;
    int y;
}
````
단위 클래스 별로 코드가 작게 나뉘어 작성되어 있기 때문에 코드를 관리하는 데도 수월하다.



#### \# is-a , has-a

> 상속관계 : '~은 ~이다.' `is-a`
>
> 포함관계 : '~은 ~을 가지고 있다.' `has-a`



#### \# 단일 상속 (single inheritance)
> 자바에서는 단일 상속만 허용한다.
>
> `다중 상속은 클래스간의 관계가 매우 복잡`해진다는 단점을 가지고 있다. 또한, 서로 다른 클래스로부터 상속받은 `멤버간의 이름이 같은 경우` 구별할 수 있는 방법이 없다는 단점을 가지고 있다.
>
> 단일 상속은 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어준다.



#### \# Object 클래스 - 모든 클래스의 조상
>  Object 클래스는 `모든 클래스 상속계층도의 최상위에 있는 조상클래스`이다.
>
> 다른 클래스로부터 상속을 받지 않는 클래스는 컴파일러에 의해 자동적으로 Object 클래스를 상속받는다.

> ```java
> class Tv extends Object {
>     // ...
> }
> ```
>
> 자바의 모든 클래스들은 Object 클래스의 멤버들을 상속 받기 때문에, Object 클래스에 정의된 멤버들을 사용할 수 있다. (toString(), equals() 등..)
>
> `Object 클래스에는 toString(), equals() 와 같은 모든 인스턴스가 가져야 할 기본적인 11개의 메서드가 정의되어 있다.`



#### \# 오버라이딩 (overriding)
>  조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것.
>
> ```java
> class Point {
>     int x;
>     int y;
>     
>     String getLocation() {
>         return "x : " + x + ", y : " + y;
>     }
> }
> 
> class Point3D extends Point {
>     int z;
>     
>     // overriding
>     String getLocation() {
>         return "x : " + x + ", y : " + y + ", z : " + z;
>     }
> }
> ```

>오버라이딩 조건
>
>- 조상 클래스의 메서드와 이름이 같아야 한다.
>- 조상 클래스의 메서드와 매개변수가 같아야 한다.
>- 조상 클래스의 메서드와 반환타입이 같아야 한다. (JDK1.5 부터 공변 반환타입이 추가되어, 반환타입을 자손 클래스의 타입으로 변경하는 것은 가능하도록 조건이 완화되었다.)
>- `접근제어자를 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.`
>- `조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.` (예외의 개수가 아닌, 같은 예외인 경우를 말하는 것.)
>- 인스턴스 메서드를 static 메서드로 또는 그 반대로 변경할 수 없다.



#### \# super
> 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 `참조변수`.
>
> super 역시 static 메서드에서는 사용할 수 없고 인스턴스 메서드에서만 사용할 수 있다.



#### \# super() - 조상 클래스의 생성자

> 자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다.
>
> 생성자의 첫 줄에서 조상클래스의 생성자를 호출해야 하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화 되어 있어야 하기 때문이다.
>
> Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자,this() 또는 super(),를 호출해야 한다.` 그렇지 않으면 컴파일러가 자동적으로 'super();'를 첫 줄에 삽입한다.
>
> 생성자가 정의되어 있는 클래스에는 컴파일러가 기본 생성자를 자동적으로 추가하지 않는다.
>
> 조상 클래스의 멤버변수는 조상의 생성자에 의해 초기화되어야 한다.`



#### \# 패키지 (package)
패키지란 클래스의 묶음이다. 패키지에는 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다.

````
- 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.
- 클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.
````

#### \# 패키지의 선언
````java
package 패키지명;
````
- 패키지명은 클래스명과 구분하기 위해 소문자로 하는 것을 원칙.
- 소스파일을 작성할 때 패키지를 선언하지 않으면 자바에서 기본적으로 '이름없는 패키지(unnamed package)'를 선언한다.
- class 추가 => `JDK설치디렉토리/jre/classes`
- jar 추가 => `JDK설치디렉토리/jre/lib/ext`



#### \# import문
> import문으로 `사용하고자 하는 클래스의 패키지를 미리 명시`해주어 소스코드에 사용되는 클래스이름에서 패키지명을 생략할 수 있다.
>
> import문의 역할은 `컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것이다.`



#### \# import문의 선언
````
일반적인 소스파일(*.java)의 구성
 1. pacakage문
 2. import문
 3. 클래스 선언
````
````
import 패키지명.클래스명;
    또는
import 패키지명.*; 
````
> System, String 같은 `java.lang 패키지`는 매우 빈번히 사용되는 중요한 클래스들이 속한 패키지이기 때문에 따로 import문으로 지정하지 않아도 된다. (모든 소스파일에 묵시적으로 import문 선언된다.) 



#### \# static import문
static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있다.

````java
// 일반 import만 한 경우
System.out.pringln(Math.random());

// static import 선언 시
import java.lang.Math.random();

System.out.println(random());
````



#### \# 제어자 (modifier)

클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

> 접근 제어자
>
> - public, protected, default, private
>
> 그 외 제어자
>
> - static, final, abstract, native, transient, synchronized, volatile, strictfp
>
> 접근 제어자 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다. 제어자들 간의 순서는 관계없지만 주로 접근 제어자를 제일 왼쪽에 놓는 경향이 있다.



#### \# static - 클래스의, 공통적인

인스턴스 변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지하지만, 클래스변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 갖는다.



#### \# final - 마지막의, 변경될 수 없는

변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없게 되고 클래스에 사용되면 자신을 확장하는 자손 클래스를 정의하지 못하게 된다.

> 대표적인 final 클래스로는 String과 Math가 있다.

> 생성자를 이용한 final 멤버 변수의 초기화
>
> - final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스 변수의 경우 생성자에서 초기화 되도록 할 수 있다.



#### \# abstarct - 추상의, 미완성의

메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.

> 추상 클래스는 아직 완성되지 않은 메서드가 존재하는 '미완성 설계도'이므로 인스턴스를 생성할 수 없다. `추상 메서드를 가지는 클래스는 추상 클래스로 선언하거나, 인터페이스로 선언되어야 한다.`



#### \# 접근 제어자

멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 `외부에서 접근하지 못하도록 제한하는 역할`을 한다.

> 접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
>
> - private : 같은 클래스 내에서만 접근이 가능하다.
> - default : 같은 패키지 내에서만 접근이 가능하다.
> - protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.
> - public : 접근 제한이 없다.

> 접근 제어자를 이용한 캡슐화
>
> - 접근 제어자를 사용하는 이유
>   - 외부로부터 데이터를 보호하기 위해서
>   - 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서



#### \# 제어자의 조합

> 메서드에 static과 abstract를 함께 사용할 수 없다.
>
> - static 메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.
>
> 클래스에 abstract와 final을 동시에 사용할 수 없다.
>
> - 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.
>
> abstract메서드의 접근 제어자가 private일 수 없다.
>
> - abstract 메서드는 자손 클래스에서 구현해주어야 하는데  접근 제어자가 private이면, 자손 클래스에서 접근할 수 없기 때문이다.
>
> 메서드에 private과 final을 같이 사용할 필요는 없다.
>
> - 접근 제어자가 private인 메서드는 오버라이딩 될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.



#### \# 다형성 (polymorphism)

객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며, 자바에서는 `한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록` 함으로써 다형성을 프로그램적으로 구현하였다.

> 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있다.
>
> ```java
> Tv t = new CaptionTv();	// 다형성
> ```

> 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
>
> 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.



#### \# 참조변수의 형변환

서로 상속관계에 있는 클래스 사이에서는 참조변수의 형변환이 가능하다.

자손 타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환만 가능하다.

> 자손타입 ==> 조상타입 (`Up-casting`) : 형변환 생략가능
>
> 조상타입 ==> 자손타입 (`Down-casting`) : 형변환 생략불가

> 형변환 생략
>
> - 참조변수가 다룰 수 있는 멤버의 개수가 `실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것`이 분명하므로 문제가 되지 않는다.
>
> 형변환 생략불가
>
> - 참조변수가 다룰 수 있는 멤버의 개수가 늘어나면, `실제 인스턴스의 멤버 개수보다 참조변수가 사용할 수 있는 멤버의 개수가 더 많아`지므로 문제가 발생할 가능성이 있다.

> 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것이 아니기 때문에 참조변수의 형변환은 `인스턴스에 아무런 영향을 미치지 않는다`.
>
> 단지 `참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절`하는 것뿐이다.

